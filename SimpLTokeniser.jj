/**
 *  A Lexical Analyser for the SimpL language for CA 448
 * 
 * @Author Richard Kavanagh 
 */


/*******************************
***** SECTION 1 - OPTIONS *****
*******************************/

options {
	JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
    STATIC = true;
}


/*************************************
***** SECTION 2 - PARSER USER CODE ***
**************************************/

PARSER_BEGIN(SimpLTokeniser)
	public class SimpLTokeniser {
		public static void main(String args[]) {
			SimpLTokeniser tokeniser;
			if (args.length == 0) {
				System.out.println("Reading from standard input . . .");
				tokeniser = new SimpLTokeniser(System.in);
			}
			else if (args.length == 1) {
				try {
					tokeniser = new SimpLTokeniser(new java.io.FileInputStream(args[0]));
				} catch (java.io.FileNotFoundException e) {
					System.err.println("File " + args[0] + " not found.");
					return;
				}
			}
			else {
				System.out.println("SLP Tokeniser: Usage is one of:");
				System.out.println(" java SimpLTokeniser < inputfile");
				System.out.println("OR");
				System.out.println(" java SimpLTokeniser inputfile");
				return;
			}

			for(Token token = getNextToken(); token.kind != EOF; token = getNextToken()){

				switch(token.kind){
					case IDENTIFIER:{
						System.out.print("IDENTIFIER("+token.image+") ");
						break;
					}
					case NUM:{
						System.out.print("NUM("+token.image+") ");
						break;
					}
					case DOUBLE:{
						System.out.print("DOUBLE("+token.image+") ");
						break;
					}
					case CHARS:{
						System.out.print("STRING("+token.image+") ");
						break;
					}
					case AND:{
						System.out.print("AND ");
						break;
					}
					case BOOL:{
						System.out.print("BOOL ");
						break;
					}
					case CONST:{
						System.out.print("CONST ");
						break;
					}
					case DO:{
						System.out.print("DO ");
						break;
					}
					case ELSE:{
						System.out.print("ELSE ");
						break;
					}
					case FALSE:{
						System.out.print("FALSE ");
						break;
					}
					case IF:{
						System.out.print("IF ");
						break;
					}
					case INT:{
						System.out.print("INT ");
						break;
					}
					case MAIN:{
						System.out.print("MAIN ");
						break;
					}
					case NOT:{
						System.out.print("NOT ");
						break;
					}
					case OR:{
						System.out.print("OR ");
						break;
					}
					case REAL:{
						System.out.print("REAL ");
						break;
					}
					case RETURN:{
						System.out.print("RETURN ");
						break;
					}
					case STRING:{
						System.out.print("STRING ");
						break;
					}
					case THEN:{
						System.out.print("THEN ");
						break;
					}
					case TRUE:{
						System.out.print("TRUE ");
						break;
					}
					case VAR:{
						System.out.print("VAR ");
						break;
					}
					case VOID:{
						System.out.print("VOID ");
						break;
					}
					case WHILE:{
						System.out.print("WHILE ");
						break;
					}
					case OTHER:{
						System.out.print("UNDEFINED TOKEN " + "("+token.image+ ") ");
						break;
					}
					default:{
						System.out.print("" + token.image + " ");
						break;
					}
			}
		}
	}
}

PARSER_END(SimpLTokeniser)


/*****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
*****************************************/



TOKEN_MGR_DECLS: {
	static int commentNestingLevel = 0;
}


/* Single level comments */
SKIP : {  "--"  { commentNestingLevel = 1 ; } : COMMENT } 
< COMMENT >  SKIP : {  "\n"  {
    commentNestingLevel -= 1;
    SwitchTo( commentNestingLevel == 0 ? COMMENT : DEFAULT ) ; } } 


/* Nested Comments */
SKIP : {  "/*"  { commentNestingLevel = 0 ; } : COMMENT } 
< COMMENT >  SKIP : {  "/*" { commentNestingLevel += 1 ; } } 
< COMMENT >  SKIP : {  "*/" {
    commentNestingLevel -= 1;
    SwitchTo( commentNestingLevel == 0 ? DEFAULT : COMMENT ) ; } } 


< COMMENT >  SKIP : {  < ~[] > } 

/* Ignoring spaces/tabs/newlines */

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}


/* Keywords */
TOKEN :  {
	< AND : "and" >
	| < BOOL : "bool" >
	| < CONST : "const" >
	| < DO : "do" >
	| < ELSE : "else" >
	| < FALSE : "false" >
	| < IF : "if" >
	| < INT : "int" >
	| < MAIN : "main" >
	| < NOT : "not" >
	| < OR : "or" >
	| < REAL : "real" >
	| < RETURN : "return" >
	| < STRING : "string" >
	| < THEN : "then" >
	| < TRUE : "true" >
	| < VAR : "var" >
	| < VOID : "void" >
	| < WHILE : "while" >
}


/* Operators, Relations and Punctuation marks */
TOKEN :  {
	< PLUS : "+" >
	| < MINUS : "-" >
	| < MULTIPLY : "*" >
	| < DIVIDE : "/" >
	| < MODULUS : "%" >
	| < EQUALS : "=" >
	| < NOTEQUALS : "!=" >
	| < LESS : "<" >
	| < GREATER : ">" >
	| < LESSEQUAL : "<=" >
	| < GREATEREQUAL : ">=" >
	| < OPENBRACKET : "(" >
	| < CLOSEBRACKET : ")" >
	| < OPENCURLY : "{" >
	| < CLOSECURLY : "}" >
	| < COMMA : "," >
	| < SEMIC : ";" >
	| < COLON : ":" >
	| < DOT : "." >
	| < ASSIGNMENT : ":=" >
	| < QUESTIONMARK : "?" >
	| < EXCLAMATION : "!" >
}


/* Numbers  */
TOKEN :  {
	< NUM : (<MINUS>)? (<DIGIT>)+ >
	| < DOUBLE : ((<MINUS>)? (<DIGIT>)+ <DOT> (<DIGIT>)+) >
	| < #DIGIT : ["0" - "9"] > 
}


/* Strings  */
TOKEN : { 
	< CHARS : <QUOTE>  ( (<CHAR>)
	 				   | (<BACKSLASH><QUOTE>)
	 				   | (<BACKSLASH><BACKSLASH>)
	 				   | (<BACKSLASH><BACKSLASH><NEWLINE>)
	 		)* <QUOTE> >
	| < #CHAR : ["a"-"z","A"-"Z", " "]>
	| < #QUOTE : ("\"") >
	| < #BACKSLASH : "\\" >
	| < #NEWLINE : "N" | "R" >
}


/* Identifiers */
TOKEN : {
	<IDENTIFIER : <LETTER> (<IDSUFFIX>)* > 
	| < #IDSUFFIX : <LETTER> | <DIGIT> | <UNDERSCORE> >
	| < #LETTER : ["a"-"z","A"-"Z"]>
	| < UNDERSCORE : "_" >	
}

/* Catch all for undefined tokens */
TOKEN : {
	<OTHER : ~[]>
}
